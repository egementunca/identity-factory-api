"""
Identity browser endpoints for listing and serving saved identity circuits.

These circuits are generated by local_mixing's `grow-identity` command
and saved to various locations under `local_mixing/experiments/`.
"""
import os
import re
from datetime import datetime
from pathlib import Path
from typing import List, Optional

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel

router = APIRouter()

# Path to the experiments directory (relative to identity-factory-api)
EXPERIMENTS_DIR = Path(__file__).parent.parent.parent.parent / "local_mixing" / "experiments"


class IdentityFileInfo(BaseModel):
    """Metadata for a saved identity circuit file."""
    filename: str
    relative_path: str  # Path relative to experiments/ for display
    wires: Optional[int] = None
    gates: Optional[int] = None
    timestamp: Optional[int] = None
    size_bytes: int
    created_at: str


class IdentityListResponse(BaseModel):
    """Response for listing identity files."""
    identities: List[IdentityFileInfo]
    total: int
    directory: str


class IdentityCircuitResponse(BaseModel):
    """Response containing the circuit data."""
    filename: str
    relative_path: Optional[str] = None
    wires: Optional[int] = None
    gates: Optional[int] = None
    circuit_str: str
    gate_count: int


def parse_identity_filename(filename: str) -> dict:
    """
    Parse identity filename to extract metadata.
    Format: identity_{wires}w_{gates}g_{timestamp}.gate
    """
    match = re.match(r"identity_(\\d+)w_(\\d+)g_(\\d+)\\.gate", filename)
    if match:
        return {
            "wires": int(match.group(1)),
            "gates": int(match.group(2)),
            "timestamp": int(match.group(3)),
        }
    return {}


def count_gates_in_file(file_path: Path) -> Optional[int]:
    """Count gates in a circuit file by counting semicolons."""
    try:
        content = file_path.read_text().strip()
        return len([g for g in content.split(";") if g.strip()])
    except:
        return None


@router.get("/saved", response_model=IdentityListResponse)
async def list_saved_identities():
    """
    List all saved circuit files from the experiments directory.
    
    Recursively searches local_mixing/experiments/ for all .gate files.
    """
    if not EXPERIMENTS_DIR.exists():
        return IdentityListResponse(
            identities=[],
            total=0,
            directory=str(EXPERIMENTS_DIR)
        )
    
    identities = []
    # Recursively find all .gate files
    for file in EXPERIMENTS_DIR.rglob("*.gate"):
        stat = file.stat()
        parsed = parse_identity_filename(file.name)
        
        # Compute relative path for display
        try:
            rel_path = file.relative_to(EXPERIMENTS_DIR)
        except ValueError:
            rel_path = file.name
        
        # If not parsed from filename, try to count gates from file
        gates = parsed.get("gates")
        if gates is None:
            gates = count_gates_in_file(file)
        
        # Format timestamp to human-readable
        if parsed.get("timestamp"):
            try:
                created_at = datetime.fromtimestamp(parsed["timestamp"]).isoformat()
            except (ValueError, OSError):
                created_at = datetime.fromtimestamp(stat.st_mtime).isoformat()
        else:
            created_at = datetime.fromtimestamp(stat.st_mtime).isoformat()
        
        identities.append(IdentityFileInfo(
            filename=file.name,
            relative_path=str(rel_path),
            wires=parsed.get("wires"),
            gates=gates,
            timestamp=parsed.get("timestamp"),
            size_bytes=stat.st_size,
            created_at=created_at
        ))
    
    # Sort by modification time descending (newest first)
    identities.sort(key=lambda x: x.created_at, reverse=True)
    
    return IdentityListResponse(
        identities=identities,
        total=len(identities),
        directory=str(EXPERIMENTS_DIR)
    )


@router.get("/saved/{file_path:path}", response_model=IdentityCircuitResponse)
async def get_identity_circuit(file_path: str):
    """
    Get the contents of a specific identity circuit file.
    
    file_path is the relative path from experiments/ directory.
    Returns the circuit string and metadata.
    """
    # Sanitize path to prevent traversal
    if ".." in file_path:
        raise HTTPException(status_code=400, detail="Invalid path")
    
    full_path = EXPERIMENTS_DIR / file_path
    
    if not full_path.exists():
        raise HTTPException(status_code=404, detail=f"Circuit file not found: {file_path}")
    
    circuit_str = full_path.read_text().strip()
    
    # Count gates (each gate is separated by ;)
    gate_count = len([g for g in circuit_str.split(";") if g.strip()])
    
    parsed = parse_identity_filename(full_path.name)
    
    return IdentityCircuitResponse(
        filename=full_path.name,
        relative_path=file_path,
        wires=parsed.get("wires"),
        gates=parsed.get("gates") or gate_count,
        circuit_str=circuit_str,
        gate_count=gate_count
    )


@router.get("/latest", response_model=IdentityCircuitResponse)
async def get_latest_identity():
    """
    Get the most recently created identity circuit.
    
    Returns the newest .gate file based on modification time.
    """
    if not EXPERIMENTS_DIR.exists():
        raise HTTPException(status_code=404, detail="No experiments directory found")
    
    files = list(EXPERIMENTS_DIR.rglob("*.gate"))
    if not files:
        raise HTTPException(status_code=404, detail="No circuit files found")
    
    # Sort by modification time (newest first)
    files.sort(key=lambda f: f.stat().st_mtime, reverse=True)
    latest = files[0]
    
    circuit_str = latest.read_text().strip()
    gate_count = len([g for g in circuit_str.split(";") if g.strip()])
    parsed = parse_identity_filename(latest.name)
    
    try:
        rel_path = str(latest.relative_to(EXPERIMENTS_DIR))
    except ValueError:
        rel_path = latest.name
    
    return IdentityCircuitResponse(
        filename=latest.name,
        relative_path=rel_path,
        wires=parsed.get("wires"),
        gates=parsed.get("gates") or gate_count,
        circuit_str=circuit_str,
        gate_count=gate_count
    )

